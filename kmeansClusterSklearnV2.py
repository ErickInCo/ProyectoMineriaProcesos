# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'kmeanscluster.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from pm4py.objects.log.importer.xes import importer as xes_importer
from pm4py.objects.log.exporter.xes import exporter as xes_exporter
from pm4py.objects.conversion.log import converter as log_converter
from pm4py.objects.log.util import dataframe_utils
from pm4py import format_dataframe
from sklearn.cluster import KMeans
from sklearn import metrics
import pandas as pd
import numpy as np
import operator
import random
import math
import time
import copy

ActividadesLI = dict()
CentroidesFinales=list()
TrazasC=list()

##Calcular la distancia euclidiana
def distancia(x,y):
    suma=0
    for i in range(0,len(x)):
        val=(x[i]-y[i])**2
        suma=suma+val
    return math.sqrt(suma)

##Genera un diccionario con los valores que van despues de x evento
def buscarDespues(evento, cluster, resultados):
    res = resultados
    ##Para cada traza en el cluster
    for x in cluster:
        ##Para cada evento en la traza desde 0 hasta n-1
        for y in range(0,len(x)-1):
            ##Si existe el evento buscado
            if evento == x[y]:
                ##Si aun no existe el valor, agregar al dic
                if res.get(x[y+1])== None :
                    res.update({x[y+1]: 1})
                ##Si el valor ya existe consular el valor actual y sumar 1 y actualizar
                else:
                    valAct=res.get(x[y+1])
                    valAct=valAct+1
                    res.update({x[y+1]: valAct})
    return res

##Genera un diccionario con los valores que van antes de x evento
def buscarAntes(evento, cluster, resultados):
    res = resultados
    ##Para cada traza en el cluster
    for x in cluster:
        ##Para cada evento en la traza desde 0 hasta n-1
        for y in range(1,len(x)):
            ##Si existe el evento buscado
            if evento == x[y]:
                ##Si aun no existe el valor, agregar al dic
                if res.get(x[y+-1])== None :
                    res.update({x[y-1]: 1})
                ##Si el valor ya existe consular el valor actual y sumar 1 y actualizar
                else:
                    valAct=res.get(x[y-1])
                    valAct=valAct+1
                    res.update({x[y-1]: valAct})
    return res
                

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(977, 806)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(120, 20, 301, 31))
        self.textEdit.setObjectName("textEdit")
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(430, 20, 75, 31))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_4 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_4.setGeometry(QtCore.QRect(40, 20, 75, 31))
        self.pushButton_4.setObjectName("pushButton_4")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(30, 100, 47, 13))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(20, 290, 61, 16))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.scrollArea = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea.setGeometry(QtCore.QRect(20, 120, 731, 161))
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 729, 159))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.textEdit_Archivo_2 = QtWidgets.QTextEdit(self.scrollAreaWidgetContents)
        self.textEdit_Archivo_2.setGeometry(QtCore.QRect(0, 0, 731, 161))
        self.textEdit_Archivo_2.setObjectName("textEdit_Archivo_2")
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.scrollArea_2 = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea_2.setGeometry(QtCore.QRect(20, 310, 941, 281))
        self.scrollArea_2.setWidgetResizable(True)
        self.scrollArea_2.setObjectName("scrollArea_2")
        self.scrollAreaWidgetContents_2 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 939, 279))
        self.scrollAreaWidgetContents_2.setObjectName("scrollAreaWidgetContents_2")
        self.textEdit_3 = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_2)
        self.textEdit_3.setGeometry(QtCore.QRect(0, 0, 941, 281))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.textEdit_3.setFont(font)
        self.textEdit_3.setReadOnly(True)
        self.textEdit_3.setObjectName("textEdit_3")
        self.scrollArea_2.setWidget(self.scrollAreaWidgetContents_2)
        self.scrollArea_3 = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea_3.setGeometry(QtCore.QRect(770, 120, 191, 161))
        self.scrollArea_3.setWidgetResizable(True)
        self.scrollArea_3.setObjectName("scrollArea_3")
        self.scrollAreaWidgetContents_3 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_3.setGeometry(QtCore.QRect(0, 0, 189, 159))
        self.scrollAreaWidgetContents_3.setObjectName("scrollAreaWidgetContents_3")
        self.textEdit_2 = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_3)
        self.textEdit_2.setGeometry(QtCore.QRect(0, 0, 191, 161))
        self.textEdit_2.setObjectName("textEdit_2")
        self.scrollArea_3.setWidget(self.scrollAreaWidgetContents_3)
        self.scrollArea_4 = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea_4.setGeometry(QtCore.QRect(560, 10, 401, 81))
        self.scrollArea_4.setWidgetResizable(True)
        self.scrollArea_4.setObjectName("scrollArea_4")
        self.scrollAreaWidgetContents_4 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_4.setGeometry(QtCore.QRect(0, 0, 399, 79))
        self.scrollAreaWidgetContents_4.setObjectName("scrollAreaWidgetContents_4")
        self.textEdit_4 = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_4)
        self.textEdit_4.setGeometry(QtCore.QRect(0, 0, 401, 81))
        self.textEdit_4.setObjectName("textEdit_4")
        self.scrollArea_4.setWidget(self.scrollAreaWidgetContents_4)
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(20, 600, 131, 16))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.pushButton_44 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_44.setGeometry(QtCore.QRect(40, 60, 101, 31))
        self.pushButton_44.setObjectName("pushButton_44")
        self.textEdit_5 = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit_5.setGeometry(QtCore.QRect(150, 60, 271, 31))
        self.textEdit_5.setObjectName("textEdit_5")
        self.pushButton_33 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_33.setGeometry(QtCore.QRect(430, 60, 75, 31))
        self.pushButton_33.setObjectName("pushButton_33")
        self.scrollArea_5 = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea_5.setGeometry(QtCore.QRect(20, 630, 941, 141))
        self.scrollArea_5.setWidgetResizable(True)
        self.scrollArea_5.setObjectName("scrollArea_5")
        self.scrollAreaWidgetContents_5 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_5.setGeometry(QtCore.QRect(0, 0, 939, 139))
        self.scrollAreaWidgetContents_5.setObjectName("scrollAreaWidgetContents_5")
        self.textEdit_6 = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_5)
        self.textEdit_6.setGeometry(QtCore.QRect(0, 0, 941, 141))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.textEdit_6.setFont(font)
        self.textEdit_6.setReadOnly(True)
        self.textEdit_6.setObjectName("textEdit_6")
        self.scrollArea_5.setWidget(self.scrollAreaWidgetContents_5)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton_4.clicked.connect(self.getfiles)
        self.pushButton_3.clicked.connect(lambda: self.ejecutar(""))

        self.pushButton_44.clicked.connect(self.getfiles2)
        self.pushButton_33.clicked.connect(lambda: self.ejecutar2(""))

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Clustering"))
        self.textEdit.setToolTip(_translate("MainWindow", "Ruta del archivo"))
        self.textEdit.setPlaceholderText(_translate("MainWindow", "ejemplo.xes"))
        self.pushButton_3.setText(_translate("MainWindow", "SUBMIT"))
        self.pushButton_4.setText(_translate("MainWindow", "Leer archivo"))
        self.label.setText(_translate("MainWindow", "Trazas"))
        self.label_2.setText(_translate("MainWindow", "Grupos"))
        self.textEdit_Archivo_2.setPlaceholderText(_translate("MainWindow", "Archivo"))
        self.textEdit_3.setPlaceholderText(_translate("MainWindow", "Grupos"))
        self.label_3.setText(_translate("MainWindow", "Nuevas Trazas"))
        self.pushButton_44.setText(_translate("MainWindow", "Leer trazas extra"))
        self.textEdit_5.setToolTip(_translate("MainWindow", "Ruta del archivo"))
        self.textEdit_5.setPlaceholderText(_translate("MainWindow", "ejemplo.xes"))
        self.pushButton_33.setText(_translate("MainWindow", "Trazas"))
        self.textEdit_6.setPlaceholderText(_translate("MainWindow", "Nuevas Trazas"))

    ##Abrir explorador de archivos para seleccionar archivos xes
    def getfiles(self):
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Single File', '', '*.xes')
        self.textEdit.setText(fileName)

    ##Abrir explorador de archivos para seleccionar archivos txt
    def getfiles2(self):
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Single File', '', '*.txt')
        self.textEdit_5.setText(fileName)


    ##Ejecuta la primera parte desde la lectura del archivo, su conversion a formato vectorial y por ultimo kmeans clustering
    def ejecutar(self, texto):
        Narchivo= self.textEdit.toPlainText()
        if Narchivo == "":
            print("Nada")
        else:
            tipo = Narchivo.split(".")
            t=tipo[-1]
            
            ##Dicionarios para combertir de evento <-> letra y evento <-> numero
            ActividadesN = dict()
            ActividadesL = dict()
            ActividadesNI = dict()
            global ActividadesLI
            ##Contador de eventos
            contA=0
            ##Inicializar lista de trazas
            listaTraza=list()

            if t=="xes":
                ##Leer archivo xes
                log = xes_importer.apply(Narchivo)
                dataframe = log_converter.apply(log, variant=log_converter.Variants.TO_DATA_FRAME)

            ##Recorrer el log de eventos y registrar cada evento
            for x in log:
                Traza=list()
                for y in x:
                    evento = y["concept:name"]
                    if evento not in ActividadesN:
                        contA=contA+1
                        ##Registrar el evento en los diccionarios de evento
                        ActividadesN[evento]=contA
                        ActividadesL[evento]=chr(contA+64)
                        ActividadesNI[contA]=evento
                        ActividadesLI[chr(contA+64)]=evento
                    ##Generar la traza en envetos tipo A,B,C,D,D,F
                    Traza.append(ActividadesL[evento])
                ##Agregar la traza a la lista de trazas
                listaTraza.append(Traza)

            ##Mostrar eventos en interfaz
            imp=""
            for y in ActividadesL:
                imp=imp+y+" = "+ActividadesL[y]+"\n"
            self.textEdit_2.setText(imp)

            ##Mostrar trazas en interfaz
            imp=""
            for y in listaTraza:
                imp=imp+str(y)+"\n"
            self.textEdit_Archivo_2.setText(imp)

            
            ##Inicializar la tabla de trazas en formato vectorial
            TablaVect=list()
            aux=list()
            
            ##Agregar un renglon auxiliar para comparar que Eleemento (A,B,C,D...ETC)
            for x in ActividadesLI.keys():
                aux.append(x)
            TablaVect.append(aux)

            ##Llenar la tabla de trazas en formato vectorial 
            for x in listaTraza:
                ##Contar el cuantos eventos de cada uno hay por traza
                contEventos = {i:x.count(i) for i in x}
                renglon=list()
                ##Comparar para llenar la tabla vectorial
                for y in TablaVect[0]:
                    ##Si la traza no tiene el evento actual se agrega un 0 en esa posicion
                    if contEventos.get(y) is None:
                        renglon.append(0)
                    ##Si la traza si contiene ese evento actual se agrega la cantidad de ese
                    ##evento que tiene
                    else:
                        renglon.append(contEventos.get(y))
                TablaVect.append(renglon)
                
            ##Eliminar el renglon auxiliar de los eventos
            TablaVect.pop(0)


            ##Proceso de kmeans clustering
            ##Numero de Centroides
            numK=10
            ##Numero de trazas
            num=len(TablaVect)-1


            ##Selecionar K clusters o centroides alazar
            listaCentroides=list()
            for x in range(0,numK):
                valrandom=random.randint(1, len(TablaVect)-1)
                listaCentroides.append(TablaVect[valrandom])

            ##Conversion de lista de centroides para la funcion de kmeans
            cdf=pd.DataFrame(listaCentroides)
            C=cdf.to_numpy()

            ##Conversion de lista de trazas para la funcion de kmeans
            Tdf=pd.DataFrame(TablaVect)
            X=Tdf.to_numpy()


            ##Ejecucion de kmeans cluster y contar el tiempo de ejecución
            tiempo_ini= time.time()
            kmean_model=KMeans(n_clusters=numK, init=C, n_init=1).fit(X)
            tiempo_ejec=time.time()-tiempo_ini


##            print("****RESULTADOS FINALES*****")
##
##            print ("\n Resultados de  ",kmean_model.get_params)
##            print ("Numero de iteraciones: ",kmean_model.n_iter_)
##            print ("Tiempo de ejecución: ",tiempo_ejec)
##            ##print ("suma de error cuadratico: ",kmean_model.inertia_)
##            print ("centroides finales: \n",kmean_model.cluster_centers_)
##            print("Grupo al que pertenece: \n",kmean_model.labels_)

            ##Mostrar datos en interfaz
            imp="****RESULTADOS FINALES*****"
            imp=imp+"\nNumero de iteraciones: "+str(kmean_model.n_iter_)
            imp=imp+"\nTiempo de ejecución: "+str(tiempo_ejec)
            self.textEdit_4.setText(imp)

            ##Mostrar Clusters en interfaz
            imp=""
            ##Inicializar clusters con listas de trazas vacias
            listaTrazasEnClusters=list()
            global TrazasC
            for x in range(0,numK):
                aux=list()
                aux2=list()
                listaTrazasEnClusters.append(aux)
                TrazasC.append(copy.deepcopy(aux2))

            ##LLenar los grupos de cada cluster con las trazas correspondientes
            for x in range(0,num):
                listaTrazasEnClusters[kmean_model.labels_[x]].append(listaTraza[x])

            TrazasC=listaTrazasEnClusters

            ##Convertir los centroides a listas para la busqueda de las nuevas trazas
            for x in kmean_model.cluster_centers_:
                CentroidesFinales.append(x.tolist())
                
            ##Mostrar los gupos de cluster con formato en la interfaz
            imp=""
            for x in range(0,numK):
                aux=""
                aux="Cluster "+str(x+1)+"\n"
                
                for y in listaTrazasEnClusters[x]:
                    aux=aux+str(y)+"\n"

                aux=aux+"\n\n"
                imp=imp+aux
            self.textEdit_3.setText(imp)


    ##Ejecuta la segunda parte desde la lectura del archivo, su conversion a formato vectorial, asignacion a cluster y recuperacion de eventos perdidos
    def ejecutar2(self, texto):
        Narchivo= self.textEdit_5.toPlainText()
        if Narchivo == "":
            print("Nada")
        else:
            ##Leer archivo
            f = open(Narchivo, "r")
            nuevasT=f.readlines()
            f.close()
            listaTraza=list()
            ##Convertir a trazas
            for x in nuevasT:
                x=x.strip('\n')
                aux=list()
                for y in x.split(","):
                    aux.append(y)
                listaTraza.append(aux)
            
            ##Inicializar la tabla de trazas en formato vectorial
            TablaVect=list()
            aux=list()
            ##Agregar un renglon auxiliar para comparar que Eleemento (A,B,C,D...ETC)
            for x in ActividadesLI.keys():
                aux.append(x)
            TablaVect.append(aux)
            
            ##Llenar la tabla de trazas en formato vectorial 
            for x in listaTraza:
                ##Contar el cuantos eventos de cada uno hay por traza
                contEventos = {i:x.count(i) for i in x}
                renglon=list()
                ##Comparar para llenar la tabla vectorial
                for y in TablaVect[0]:
                    ##Si la traza no tiene el evento actual se agrega un 0 en esa posicion
                    if contEventos.get(y) is None:
                        renglon.append(0)
                    ##Si la traza si contiene ese evento actual se agrega la cantidad de ese
                    ##evento que tiene
                    else:
                        renglon.append(contEventos.get(y))
                TablaVect.append(renglon)
                
            ##Eliminar el renglon auxiliar de los eventos
            TablaVect.pop(0)


            ##Calcular distacias con los centroides de las nuevas trazas
            tablaDistancias=list()
            for x in range(0,len(TablaVect)):
                renglon=list()
                for y in CentroidesFinales:
                    renglon.append(distancia(TablaVect[x],y))
                tablaDistancias.append(renglon)

            global TrazasC
            imp=""

            ##Asignacion a cluster y recuperacion de eventos perdidos
            for x in range(0,len(tablaDistancias)):
                valmin=min(tablaDistancias[x])
                cluster=tablaDistancias[x].index(valmin)
                eventosProbables=dict()
                eventosProbables.clear()
                eventosProbablesA=dict()
                eventosProbablesA.clear()
                eventosProbablesD=dict()
                eventosProbablesD.clear()
                nTrazaCompleta=list()
                ##Recorrer la traza y detectar eventos perdidos ('-')
                for y in range(0,len(listaTraza[x])):
                    ##Si el evento es el primero o el ultimo elemento pasar directamente
                    if y==0 or y==len(listaTraza[x])-1:
                        nTrazaCompleta.append(listaTraza[x][y])
                    else:
                        ##Si el evento esta perdido ('-') buscar los eventos probables antes y despues de este
                        if listaTraza[x][y] == '-':
                            eventosProbablesA=buscarAntes(listaTraza[x][y+1],TrazasC[cluster],eventosProbablesA)
                            eventosProbablesD=buscarDespues(listaTraza[x][y-1],TrazasC[cluster],eventosProbablesD)

                            ##Por si no hay interseccion valida usar estos datos
                            eventosProbables=buscarAntes(listaTraza[x][y+1],TrazasC[cluster],eventosProbables)
                            eventosProbables=buscarDespues(listaTraza[x][y-1],TrazasC[cluster],eventosProbables)
                            
                            ##Calcular la interseccion
                            intersection = eventosProbablesA.keys() & eventosProbablesD.keys()

                            valoresEnInter=dict()
                            ##Sumar los valores de cada evento en la interseccion
                            for i in intersection:
                                vA=eventosProbablesA[i]
                                vD=eventosProbablesD[i]
                                valoresEnInter.update({i: vA+vD})
                            ##Almacenar la letra del evento mas probable
                            if len(intersection)>0:
                                letraMasP=max(valoresEnInter.items(), key=operator.itemgetter(1))[0]
                            else:
                                letraMasP=max(eventosProbables.items(), key=operator.itemgetter(1))[0]
                            ##Agregar a la traza
                            nTrazaCompleta.append(letraMasP)
                            eventosProbables.clear()
                            eventosProbablesA.clear()
                            eventosProbablesD.clear()
                            valoresEnInter.clear()
                            intersection.clear()
                        ##Si es un evento conocido, solo agregar a la traza
                        else:
                            ##Agregar a la traza
                            nTrazaCompleta.append(listaTraza[x][y])
                ##Elavoracion de cadena para mostrar en interfaz
                imp=imp+str(listaTraza[x])+" Cluster "+str(cluster+1)+"\n"+str(nTrazaCompleta)+"\n"+"\n"+"\n"

                TrazasC[cluster].append(listaTraza[x])

            ##Mostrar en interfaz los resultados
            self.textEdit_6.setText(str(imp))

            
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
